---
title: "Emanuel Sonder's SMP on Wang's early embryos"
author: "Izaskun Mallona at Mark D. Robinson lab, UZH"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
    number_sections: true
    df_print: kable
    theme: lumen
params:
  seed: 665
---

```{r}
library(VGAM)
library(mhsmm)
library(data.table)
library(knitr)
library(genomation)
library(AnnotationHub)
library(GenomicRanges)
## library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(TxDb.Mmusculus.UCSC.mm9.knownGene)
library(GEOquery)
library(Matrix)
## library(mltools) # just for sparsify()
library(readxl) # for ICRs import
library(annotatr)
```

```{r}
opts_chunk$set(fig.width = 5,
               fig.height = 5,
               cache = TRUE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               message = FALSE)


options(bitmapType='cairo')
```

```{r}
CODE <- '/home/imallona/src/smp'
WD <- file.path('/home/imallona', 'smp_test')
GSE <- 'GSE136718'

NTHREADS = 35
```

```{r}
setDTthreads(NTHREADS)
```

```{r}]
## load smp functions
wd <- getwd()
setwd(file.path(CODE))

for (fn in list.files(file.path(CODE, 'R'))) {
    source(file.path(CODE, 'R', fn))
}

setwd(wd)
```

# Aim

Data from https://www.nature.com/articles/s41467-021-21409-8#data-availability and https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE136718 .

This is mm9.

Please run `get_data.sh` first.

# (meta) data retrieval

```{r, eval = FALSE}
## run `get_data.sh` instead
supp <- getGEOSuppFiles(GSE, fetch_files = FALSE)$url
if (!file.exists( file.path(WD, paste0(GSE, '.tar')))){
    system(command = sprintf('wget %s --output-file %s', supp, file.path(WD, paste0(GSE, '.tar'))))
}
```

Metadata retrieval

```{r, message = FALSE}
gsml <- getGEO(GSE, GSEMatrix = FALSE)

head(names(GSMList(gsml)))
meta <- data.frame(id = names(GSMList(gsml)),
                   source_name_ch1 = NA,
                   library_strategy = NA,
                   title = NA,
                   description = NA, row.names = 1)

for (id in rownames(meta)) {
    for (feat in colnames(meta)) {
        tryCatch({
            meta[id,feat] <- Meta(GSMList(gsml)[[id]])[feat]
        }, error = function(x) return(NA))
    }
}

## table(meta$library_strategy)
## head(meta$title)
meta$tr <- sapply(regmatches(meta$title, gregexpr("\\[[^][]*]", meta$title)),
                  function(x) return(x[1]))
meta$id <- sprintf('%s_%s', rownames(meta), gsub('[[:punct:]]', '', meta$tr))

```

Build a (nonsparse) locus x cell table for CpG methylation

```{r}
d <- list()
## i <- 1
for (fn in list.files(WD, pattern = "*WCG.dat.gz")) {
    d[[fn]] <- fread(file.path(WD, fn),
                     header = FALSE,
                     col.names = c('id', gsub('.dat.gz', '', basename(fn))))
    ## i <- i +1
    ## if (i ==10) stop('')
}

str(d)

merged <- Reduce(function(x, y) merge(x, y, all = TRUE, by = 'id'), d)
merged[1:3, 1:3]
rm(d)
gc()

```

Conventional export

```{r}
saveRDS(merged, file =  file.path(WD, sprintf('%s_all.rds', GSE)))
```

Export the beta values with an offset of 1, to encode NAs as `0` (not stored), unmethylations as `1`, and full methylations as `2`.

```{r}
# export
loci <- merged$id
merged <- merged[,-1]
cells <- colnames(merged)
## merged[merged == 0] <- 2
## merged[is.na(merged)] <- 0
merged <- merged + 1
merged[is.na(merged)] <- 0

merged <- as(as.matrix(merged), 'dgCMatrix')
dimnames(merged) <- list(loci, cells)
Matrix::writeMM(file = file.path(WD, sprintf('%s_all.mm', GSE)),
                obj = merged)

```

# Add ICRs

As described by https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3343639/bin/NIHMS353366-supplement-03.xls

This is mm9 according to suppl. material 1, page 7.

```{r}
system(sprintf('wget %s -O %s', "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3343639/bin/NIHMS353366-supplement-03.xls", file.path(WD, 'icrs_PMC3343639_mm9.xls')))
icrs <- read_excel(file.path(WD, 'icrs_PMC3343639_mm9.xls'), skip = 3)
icrs <- as.data.frame(icrs)

```

# Calculate entropies

Downsampling data to 1e4 CpGs from chr4 for testing purposes

```{r}
## the coercion is because of the MM export : `merged` is a dgCMatrix now
metTable <- as.data.table(as.data.frame(as.matrix(head(merged[grep('chr4:', rownames(merged)),],
                                                       1e4))))

## this is quite absurd, it's 4 for all - but kept like this for eventually longer runs
chr <- as.numeric(gsub('chr', '', sapply(strsplit(rownames(met), ':'), function(x) return(x[1]))))
pos <- as.numeric(sapply(strsplit(rownames(met), ':'), function(x) return(x[2])))
metTable <- cbind(chr, pos, met)
```


```{r}
meta$cell <- sprintf('%s.WCG', meta$id)
rownames(meta) <- meta$cell

## plus deleting any metadata for cells not present at the meth table

meta <- meta[meta$cell %in% colnames(met),]

```

Binning the metTable in blocks of 100 CpGs each

```{r}
## weird binning here
metTable$bin <- rep(1: (nrow(metTable)/100), each = 100)
```

```{r}
tryCatch({
    seh <- heightShannonEn(metTable = metTable,
                           cellIds = meta$cell,
                           aggregateOn = 'bin')
}, error = function(x) print(x))
```


```{r}

## this crashes
tryCatch({
    tew <- widthKeepSampEn(metTable = metTable,
                          cellIds = meta$cell,
                          nTempsBin = 32,
                          templateDim = 2,
                          tiledBinning = TRUE)
}, error = function(x) print(x))
```

```{r}
## crashes too
tryCatch({
    mhl <- widthMHL(metTable = metTable, cellIds = meta$cell)
                         
}, error = function(x) print(x))
```


# Get annotations

```{r}
ah <- AnnotationHub()

txdb <- TxDb.Mmusculus.UCSC.mm9.knownGene
proms <- promoters(txdb)[seqnames(promoters(txdb)) == "chr4"]
genes <- genes(txdb)[seqnames(genes(txdb)) == "chr4"]

## repeat masker
rmsk <- query(ah, c("RepeatMasker", "mm9"))[['AH6155']]
trna <- query(ah, c("tRNA Genes", "mm9"))[['AH6099']]
mirna <- query(ah, c("miRNA", "mm9"))[['AH6101']]

## cpgislands
cpgi <- query(ah, c("CpG Islands", "mm9"))[['AH6117']]

## evolutionarily conserved protein-coding exons
exoniphy <- query(ah, c("Exoniphy", "mm9"))[['AH6098']]
```

Next, shall we overlap each annotation layer against the entropies and use the matches as the bins? Or rather fixed-window-bin the genome and overlap against these annotations?

Rather, use annotatr; TODO add ICRs, PMDs, TFBS scans by FIMO etc

```{r}
annots <- grep('mm9', builtin_annotations(), value = TRUE)

annotations <- build_annotations(genome = 'mm9', annotations = annots)
```

Transform the current entropy run entropies into GR?

```{r}
## entropy outputs have no coordinates: a mapping bin:coordinates is needed
##  but the bin might be not contiguous... maybe one of the methods run modes should be a
##  genome scan with a fixed number of windows and an univocal translation to coordinates?

## ew_gr <- makeGRangesFromDataFrame(metTable,
##                                   keep.extra.columns = TRUE,
##                                   ignore.strand = FALSE,
##                                   seqinfo = NULL,
##                                   seqnames.field = "seqnames",
##                                   start.field = "bin_start",
##                                   end.field = c("bin_end"),
##                                   starts.in.df.are.0based = FALSE)

```


```{r, eval = FALSE}
stop('till here')

dm_annotated = annotate_regions(
    regions = dm_regions,
    annotations = annotations,
    ignore.strand = TRUE,
    quiet = FALSE)
# A GRanges object is returned
print(dm_annotated)

# Build the annotations (a single GRanges object)
```

# sessionInfo

```{r}
sessionInfo()
date()
devtools::session_info()
```
